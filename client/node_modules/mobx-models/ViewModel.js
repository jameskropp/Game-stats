'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mobx = require('mobx');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assign = Object.assign;

/**
 * ViewModel is a class that can emulate a model without changing the underlying model's properties.
 * 
 * @example
 * class InfluencerViewModel extends ViewModel {}
 * const vm = new InfluencerViewModel(influencerInstance)
 * vm.name = 'new name'
 * 
 * // calls view model validate(), and commit's changes to the model if
 * // everything looks ok.
 * vm.commit()
 * vm.commitAndSave() // does what you think
 * 
 */

var ViewModel = function () {
  // this is a copy of the model

  /**
   * Instantiate with the model to emulate.
   * @param {Model} model
   */
  // the root model
  function ViewModel(model) {
    _classCallCheck(this, ViewModel);

    this.model = model;

    (0, _mobx.extendObservable)(this, {
      errors: {},
      data: {}
    });

    // Mark the data as observable as well as proxy all of the keys from this object.
    (0, _mobx.extendObservable)(this.data, this.original);
    proxyTo(this, this.data);
  }

  /**
   * Implement this method to validate model properties, commit will fail if this method returns false.
   * @returns {Boolean}
   */
  // errors are observables can be used how you wish


  _createClass(ViewModel, [{
    key: 'validate',
    value: function validate() {
      return true;
    }

    /**
     * Commit the changes back to the root model only if they are valid.
     * @returns {Boolean}
     */

  }, {
    key: 'commit',
    value: function commit() {
      if (!this.validate()) return false;

      assign(this.model, (0, _mobx.toJS)(this.data));
      return true;
    }

    /**
     * Commit the changes back to the root model only if they are valid. If validation fails, the promise will be rejected
     * with the view model's errors.
     * @returns {Promise}
     */

  }, {
    key: 'commitAndSave',
    value: function commitAndSave() {
      if (this.commit()) return this.model.save();
      return Promise.reject(this.errors);
    }

    /**
     * The model's original data.
     * @returns {Object}
     */

  }, {
    key: 'reset',


    /**
     * Reset to the original data. Return's self.
     * @returns {ViewModel}
     */
    value: function reset() {
      assign(this.data, this.original);
      return this;
    }
  }, {
    key: 'original',
    get: function get() {
      return this.model.data || (0, _mobx.toJS)(this.model);
    }
  }]);

  return ViewModel;
}();

exports.default = ViewModel;


function proxyTo(root, obj) {
  Object.keys(obj).forEach(function (key) {
    Object.defineProperty(root, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return obj[key];
      },
      set: function set(val) {
        return obj[key] = val;
      }
    });
  });
}