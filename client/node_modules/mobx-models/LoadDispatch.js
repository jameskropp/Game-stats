"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * LoadDispatch is a load dispatcher, register your loaders with it and then call all of them later. It's only use is the
 * asReactiveLoader currently.
 * 
 * @example
 * class MyComponent {
 *   componentDidMount() {
 *     LoadDispatch.callLoaders(this.id)
 *   }
 *   
 *   render() {
 *     LoadDispatch.beginListening(this.id)
 *     const results = (
 *       <div>
 *         {this.props.collection.map(...)}
 *       </div>
 *     )
 *     LoadDispatch.endListening()
 *     return results
 *   }
 * }
 */
var LoadDispatch = function () {
  function LoadDispatch() {
    _classCallCheck(this, LoadDispatch);

    this._loaders = {};
    this._listening = false;
    this._currentComponent = undefined;
  }

  _createClass(LoadDispatch, [{
    key: "callLoaders",


    /**
     * Call the loaders for a specific component.
     * @param {String} component
     */
    value: function callLoaders(component) {
      this._loaders[component].forEach(function (fn) {
        fn();
      });
    }

    /**
     * Register a loader, this is a function that should load data for a specific object.
     * @param {Function} fn
     */

  }, {
    key: "registerLoader",
    value: function registerLoader(fn) {
      if (this._listening) {
        this._loaders[this._currentComponent].push(fn);
      }
    }

    /**
     * Begin listening to a component.
     * @param {String} component
     */

  }, {
    key: "beginListening",
    value: function beginListening(component) {
      this._currentComponent = component;
      this._listening = true;
      this._loaders[component] = [];
    }

    /**
     * End listening to a component.
     */

  }, {
    key: "endListening",
    value: function endListening() {
      this._listening = false;
      this._currentComponent = undefined;
    }
  }]);

  return LoadDispatch;
}();

var loadDispatch = new LoadDispatch();
exports.default = loadDispatch;